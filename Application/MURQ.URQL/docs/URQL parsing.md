# Распознавание URQL
## Этапы распознавания
URQL загружается как входной поток символов и последовательно проходит через следующие этапы, где фильтруется, обогащается и распознаётся в структуры:

| № | Этап  | Тип   | Описание
| -:| ----- |:-----:| --------
| 1 | Удаление ненужных символов    | Фильтр    | Удаляются ненужные символы (пока это только символ возврата каретки `<CR>`).
| 2 | Добавление координат  | Обогащение    | К каждому символу добавляется координата $[строка, колонка]$.
| 3 | Удаление комментариев | Фильтр    | Удаляются однострочные и многострочные комментарии.
| 4 | Схлопывание переносов | Фильтр    | Переносы `_` схлопываются (строки склеиваются).
| 5 | Разбивка на строки    | Распознавание | Весь поток символов бьётся на строки по символу новой строки `<LF>`.
| 6 | Распознавание подстановок | Распознавание | Строка распознаётся как набор подстановок.
| 7 | Предварительное распознавание команд  | Распознавание | Если в строке нет подстановок, она распознаётся как команда URQ.

### Выходной результат
После прохождения всех 6 этапов на выходе получается список, состоящий из двух типов элементов: распознанных URQ-команд и распознанных (но не вычисленных) подстановок.

### Пример обработки кода
Возьмём для примера следующий URQL-код:
```urql
perkill & z="if" & a = 1 & #%z$ /* сюда должен попасть if */ a
	_ then pln #a$ & pln верная ветка
	_ else pln неверная ветка ; а это коммент в конце
pln Вторая строка
_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно
```
#### Этап 1. Удаление ненужных символов
В примере нет явного символа возврата каретки `<CR>`, поэтому пример выглядит точно так же:
```urql
perkill & z="if" & a = 1 & #%z$ /* сюда должен попасть if */ a
        _ then pln #a$ & pln верная ветка
        _ else pln неверная ветка ; а это коммент в конце
pln Вторая строка
_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно
```

#### Этап 2. Добавление координат
Т.к. для каждого символа добавляется структура с координатами, мы опустим её в примерах и оставим только строку:
```urql
perkill & z="if" & a = 1 & #%z$ /* сюда должен попасть if */ a
        _ then pln #a$ & pln верная ветка
        _ else pln неверная ветка ; а это коммент в конце
pln Вторая строка
_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно
```

#### Этап 3. Удаление комментариев
```urql
perkill & z="if" & a = 1 & #%z$  a
        _ then pln #a$ & pln верная ветка
        _ else pln неверная ветка
pln Вторая строка
_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно
```

#### Этап 4. Схлопывание переносов
```urql
perkill & z="if" & a = 1 & #%z$  a then pln #a$ & pln верная ветка else pln неверная ветка
pln Вторая строка
_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно
```

#### Этап 5. Разбивка на строки
| # | Строка |
|-:|-|
| 1 | `perkill & z="if" & a = 1 & #%z$  a then pln #a$ & pln верная ветка else pln неверная ветка` |
| 2 | `pln Вторая строка` |
| 3 | `_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно` |

#### Этап 6. Распознавание подстановок
Вся строка распознаётся как строка с подстановками. На выходе получается древовидная структура (конкретная структура и названия полей примерные):
```plantuml
@startjson
[
    {"Parts":[{"Text":"perkill & z=\"if\" & a = 1 & "},{"Modifier":"AsString","Parts":[{"Text":"z"}]},{"Text":"  a then pln "},{"Modifier":"None","Parts":[{"Text":"a"}]},{"Text":" & pln верная ветка else pln неверная ветка "}]},
    
    {"Parts":[{"Text":"pln Вторая строка"}]},

    {"Parts":[{"Text":"_не_перенос = 1 & if _не_перенос then pln Переносы распознаются верно else pln Переносы распознаются НЕ верно"}]}
]
@endjson
```

#### Этап 7. Предварительное распознавание команд
~~Т.к. у нас одна строка и она с подстановками, предварительно распознать команды в ней нельзя, поэтому она остаётся как есть.~~

### Открытые вопросы
#### Этап "Удаление ненужных символов"
- Возможно, есть полезные символы, которые при этом не являются печатными (при выводе на экран не образуют символа, даже пробельного) - например, символ сигнала (`BELL`) может быть полезным для воспроизведения звука, но при этом не печатный.