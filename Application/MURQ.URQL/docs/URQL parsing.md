# Распознавание URQL
## Этапы распознавания
URQL загружается как входной поток символов и последовательно проходит через следующие этапы, где фильтруется, обогащается и распознаётся в структуры:

| № | Этап  | Тип   | Описание
| -:| ----- |:-----:| --------
| 1 | Удаление ненужных символов    | Фильтр    | Удаляются ненужные символы (пока это только символ возврата каретки `<CR>`).
| 2 | Добавление координат  | Обогащение    | К каждому символу добавляется координата $[строка, колонка]$.
| 3 | Удаление комментариев | Фильтр    | Удаляются однострочные и многострочные комментарии.
| 4 | Схлопывание переносов | Фильтр    | Переносы `_` схлопываются (строки склеиваются).
| 5 | Разбивка на строки    | Распознавание | Весь поток символов бьётся на строки по символу новой строки `<LF>`.
| 6 | Распознавание подстановок | Распознавание | Строка распознаётся как набор подстановок.
| 7 | Предварительное распознавание команд  | Распознавание | Если в строке нет подстановок, она распознаётся как команда URQ.

### Выходной результат
После прохождения всех 6 этапов на выходе получается список, состоящий из двух типов элементов: распознанных URQ-команд и распознанных (но не вычисленных) подстановок.

### Пример обработки кода
Возьмём для примера следующий URQL-код:
```urql
perkill & z="if" & a = 1 & #%z$ /* тут должен попасть if */ a
_ then pln #a$ & pln верная ветка
_ else pln неверная ветка ; а это коммент в конце
```
#### Этап 1. Удаление ненужных символов
В примере нет явного символа возврата каретки `<CR>`, поэтому пример выглядит точно так же:
```urql
perkill & z="if" & a = 1 & #%z$ /* тут должен попасть if */ a
_ then pln #a$ & pln верная ветка
_ else pln неверная ветка ; а это коммент в конце
```

#### Этап 2. Добавление координат
Т.к. для каждого символа добавляется структура с координатами, мы опустим её в примерах и оставим только строку:
```urql
perkill & z="if" & a = 1 & #%z$ /* тут должен попасть if */ a
_ then pln #a$ & pln верная ветка
_ else pln неверная ветка ; а это коммент в конце
```

#### Этап 3. Удаление комментариев
```urql
perkill & z="if" & a = 1 & #%z$  a
_ then pln #a$ & pln верная ветка
_ else pln неверная ветка 
```

#### Этап 4. Схлопывание переносов
```urql
perkill & z="if" & a = 1 & #%z$  a then pln #a$ & pln верная ветка else pln неверная ветка 
```

#### Этап 5. Разбивка на строки
Т.к. в примере только одна строка, то результат выходит такой же:
```urql
perkill & z="if" & a = 1 & #%z$  a then pln #a$ & pln верная ветка else pln неверная ветка 
```

#### Этап 6. Распознавание подстановок
Вся строка распозаётся как строка с подстановками. На выходе получается древовидная структура (конкретная структура и названия полей примерные):
```plantuml
@startjson
[
    {"string": "perkill & z=\"if\" & a = 1 & "},
    {
        "expression":
        {
            "identifier": "z"
        },
        "modifiers": "as string"
    },
    {"string": "  a then pln "},
    {
        "expression":
        {
            "identifier": "a"
        }
    },
    {"string": " & pln верная ветка else pln неверная ветка "}
]
@endjson
```

#### Этап 7. Предварительное распознавание команд
Т.к. у нас одна строка и она с подстановками, предварительно распознать команды в ней нельзя, поэтому она остаётся как есть.

### Открытые вопросы
#### Этап "Удаление ненужных символов"
- Возможно, есть полезные символы, которые при этом не являются печатными (при выводе на экран не образуют символа, даже пробельного) - например, символ сигнала (`BELL`) может быть полезным для воспроизведения звука, но при этом не печатный.